## 网络同步模型

帧一般分为**逻辑帧**和**渲染帧**，其中：

逻辑帧（Tick），游戏在逻辑层面是离散的过程，即可以认为是一个逻辑帧一个逻辑帧地进行逻辑运算，逻辑帧号是指游戏逻辑层面当前处于第几帧。

渲染帧（Frame），游戏在画面呈现层面也是离散的过程，即可以认为是一副画面一副画面地呈现给玩家的，渲染帧号是指游戏当前呈现的是第几幅画面。

游戏的逻辑帧率和渲染帧率是互相独立的，比如一个游戏可以是 20 帧每秒的逻辑帧率和 60 帧每秒的渲染帧率。

游戏逻辑可以抽象为：
$$
S_k = \begin{cases} g(P,C) &if\space k=0\\ t(S_{k-1},C,I_k) &if\space k\geqslant 1\end{cases}
$$
游戏在第 0 个逻辑帧时，根据玩家信息 $P$ 和游戏配置 $C$，进行初始化运算 $g$，得出初始化状态集合 $S_0$。

游戏在第 $k$ 个逻辑帧时，根据前一个状态集合 $S_{k-1}$ 和游戏配置 $C$，根据第 $k$ 帧收到的外部变化原因集合 $I_k$，进行逻辑 $t$ 运算，得出第 $k$ 个逻辑帧新的游戏状态集合 $S_k$。

$I$ 是游戏状态变化的根本原因的集合，往往是各个玩家操作。$S$ 是游戏状态的集合，由众多状态子集组成，其中有以下 2 个重要子集定义：
$$
O=\{ o\in S\space | \space o是一个能被玩家观察到的重要状态 \} \\
M=\{ m\in S\space |\space m是一个用于推导最终状态的中间状态 \}
$$
在网络同步中，**从客户端发出信息进行网络传输的过程称为上行，客户端经过网络传输收到信息的过程称为下行**。

一般锁步同步的本质是，上下行都仅包含游戏外部变化原因集合 $I_k$。

一般状态同步的本质是，下行仅包含游戏运算得出的结果状态集合 $S_k$（更精确地说是状态子集 $O_k$），上行包含 $I_k$ 和/或状态子集 $M_k$。

锁步同步和状态同步最大的区别就是战斗核心逻辑写在哪里，状态同步的战斗逻辑在服务器，锁步同步的战斗逻辑在客户端。战斗逻辑是包含技能逻辑、普攻、属性、伤害、移动、AI、检测、碰撞等等的一系列内容。由于核心逻辑必须知道一个场景中的所有实体情况，所以 MMO 游戏（例如魔兽世界）就必须把战斗逻辑写在服务器，所以 MMO 游戏必须是状态同步的，因为 MMO 游戏的客户端承载有限，并不能把整张地图的实体全部展现出来，所以客户端没有足够的信息计算全图的人的所有行为。

### 锁步同步 Lockstep

因为锁步同步只同步变化的原因 $I_k$，所以要求各个客户端的运算逻辑 $g$，$t$ 是严格确定性的，所有客户端才能算出严格一致的结果 $S_k$。游戏要做到严格确定性，需要做好一些事情：

- 不使用浮点数而使用定点数，或限定各客户端所运行的硬件及操作系统从而浮点数的运算是一致的
- 确定性的随机数机制
- 确定性的容器及算法（增加、移除、排序等）
- 隔离和封装逻辑层，以防止其它不确定性的调用
- 确定性的物理机制、导航机制、动画骨骼机制等
- 排查所有引起异常的逻辑

制定检测不同步的管线流程对锁步同步游戏来说是至关重要的，比如帧状态哈希对比、静态代码扫描分析、帧级别甚至函数级别的高性能日志、外网不同步率统计等。

### 状态同步 State Synchronization

因为状态同步只同步游戏运算得出的结果状态 $S_k$，所以需要有机器来进行权威的状态计算，并传输给其它机器，其它机器都将采纳接受到的状态。

状态同步开发过程中最基础也最重要的是，不管客户端网络对象当前处于什么状态，它都要做到能正确地完全退出旧状态，退出后不能残留旧状态的逻辑层效果，并正确地进入服务器告知的新权威状态，从而带来新状态的逻辑层效果。

### 锁步同步和状态同步的对比

|                          | 锁步同步                                                     | 状态同步                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 流量                     | 一般情况下较低，决定于网络玩家数目                           | 一般情况下较高，决定于当前该客户端可观察到的网络实体数目     |
| 预表现                   | 难，客户端需本地进行状态序列化反序列化，进行Roll-Forth       | 较易，客户端进行预表现，服务器进行权威演算，客户端最终和服务器下发的状态进行调节和Roll-Forth |
| 确定性                   | 须要严格确定性                                               | 须要不严格确定性                                             |
| 对弱网络的适应能力       | 较低，因为较难做到预表现                                     | 较高，因为较易做到预表现                                     |
| 断线重连                 | 较难，需比较耗时地进行快播追上实时进度的游戏状态             | 较易，服务器下发当前实时游戏状态的Snapshot即可               |
| 离线重播                 | 较易，且重播文件大小较小                                     | 较易，但重播文件较大                                         |
| 实时重播                 | 难，视乎需求，客户端可能需要本地每帧都进行全场状态序列化，从而能发序列化回到过去，并进行重播，播完后再快播追上实时游戏状态 | 较易，服务器下发历史Snapshot给客户端回到过去，下发重播数据进行重播，再下发当前Snapshot恢复实时游戏 |
| 网络逻辑性能优化         | 较难，因为客户端需要运算所有逻辑                             | 较易，大部分逻辑默认是在服务器进行运算，从而分担客户端运算压力，服务器也可 |
| 大量网络实体时的流量情况 | 好，因为流量只决定于网络玩家数目                             | 如果客户端可观察到的网络实体较少，则较好，比如PUBG等BattleRoyale类型；否则如果客户端可观测到的网络实体较多，则较差，比如Starcraft等RTS |
| 外挂                     | 因为客户端拥有所有信息，所以透视类外挂的影响会比较严重       | 也会有透视类外挂，但服务器会进行一定的视野剔除，所以影响稍小 |
| 开发特征                 | 平时开发起来很高效，不需要前后端联调，但写代码时需要确保确定性，心智负担较大，不同步bug如果出现，对版本质量是灾难性的 | 平时开发起来效率一般，需要前后端联调（LocalHost自测起来效率很高，但和最终C-S的真实情况不尽相同，自测应以后者为准，故依然需要联调），但写代码时不需确保确定性，心智负担较小，无不同步的bug |
| 采用第三方库             | 较难，因为第三方库也须确保确定性                             | 较容易，因为第三方库不须确保确定性                           |

### 网络拓扑结构

网络拓扑结构，是指参与游戏的机器的网络连接方式，主要包括**对等结构**（P2P 结构）和**主从结构**（CS 结构）。

#### 对等结构

P2P 结构是网状结构，游戏中的 P2P 一般是全连接的网状结构，如下所示。P2P 结构中所有客户端两两相连，连接数为 $O(n^2)$ ，地位平等，功能一致。

<img src="https://pic1.zhimg.com/80/v2-153671959a37d1a29de7939f43b12bb8_1440w.jpg" alt="img" style="zoom:50%;" />

#### 主从结构

CS 结构是星状结构，如下所示。CS 结构有至少一部机器为服务器。当运行服务器的机器只用于逻辑运算游戏状态，只用于下发状态给客户端，和客户端完全分离的机器时，该服务器称为 Dedicated Server；当运行服务器的机器同时也在运行客户端运算，也被玩家所控制时，该服务器称为 Listen Server，也称为 Host。

<img src="https://pic3.zhimg.com/80/v2-f1d3a725c00939d80b533d8b13354c7a_1440w.jpg" alt="img" style="zoom:50%;" />

#### 两种网络拓扑结构的对比

|                | P2P结构                    | CS结构                         |
| -------------- | -------------------------- | ------------------------------ |
| 连接数         | $O(n^2)$                   | $O(n)$                         |
| 流量           | 各客户端相等，都为$O(n^2)$ | 服务器为$O(n)$，客户端为$O(1)$ |
| 客户端之间时延 | 较小，为$RTT/2$            | 较大，为$RTT$                  |

### 网络同步模型和网络拓扑结构组合

|          | P2P结构                                                      | CS结构                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 锁步同步 | 把本地机器玩家的操作广播给其它机器                           | 把本地客户端玩家的操作发送给服务器，服务器再广播给所有客户端 |
| 状态同步 | 各个机器只对自己控制的角色有权威，向其它机器广播自己控制角色的权威状态 | 把本地客户端玩家的操作发送给服务器，服务器再把根据客户端的情况发送需要的网络实体的权威状态 |

### 帧锁定同步算法

该算法普遍要求网速 RTT 在 100ms 以内，一般人数不超过 8 人，在这样的情况下，可以像单机游戏一样编写网络游戏。所有客户端任意时刻逻辑都是统一的，缺点是一个人卡机，所有人等待。

1. 客户端定时（比如每五帧）上传控制信息
2. 服务器收到所有控制信息后广播给所有客户
3. 客户端用服务器发来的更新消息中的控制信息进行游戏
4. 如果客户端进行到下一个关键帧（五帧后）时没有收到服务器的更新消息则等待
5. 如果客户端进行到下一个关键帧时已经接受到了服务器的更新消息，则将上面的数据用于游戏，并采集当前鼠标键盘输入发送给服务器，同时继续进行下去
6. 服务器采集到所有数据后再次发送下一个关键帧更新消息

这个等待关键帧更新数据的过程称为**帧锁定**。

#### 算法流程

客户端逻辑：

1. 判断当前帧 F 是不是关键帧 K1，如果不是跳转 7 
2. 如果是关键帧，则查看有没有 K1 的 UPDATE 数据，如果没有的话重复 2 等待
3. 采集当前 K1 的输入作为 CTRL 数据与 K1 编号一起发送给服务器
4. 从 UPDATE K1 中得到下一个关键帧的号码 K2 以及到下一个关键帧之间的输入数据 I
5. 从这个关键帧到下一个关键帧 K2 之间的虚拟输入都用 I
6. 令 K1=K2
7. 执行该帧逻辑
8. 跳转 1 

服务器逻辑：

1. 收集所有客户端本关键帧 K1 的 CTRL 数据（CTRL-K），等待直到收集完所有的 CTRL-K
2. 根据所有 CTRL-K，计算下一个关键帧 K2 的 UPDATE，计算再下一个关键帧的编号 K3
3. 将 UPDATE 发送给所有客户端
4. 令 K1=K2
5. 跳转 1 

![img](http://www.skywind.me/blog/wp-content/uploads/2011/04/framelock1.png)

服务器根据所有客户端的最大 RTT，平滑计算下一个关键帧的编号，让延迟根据网络情况自动调整。

#### 乐观帧锁定

针对传统严格帧锁定算法中网速慢会卡到网速快的问题，实践中线上动作游戏通常用“定时不等待”的乐观方式再每次 Interval 时钟发生时固定将操作广播给所有用户，不依赖具体每个玩家是否有操作更新：

1. 单个用户当前键盘上下左右攻击跳跃是否按下用一个 32 位整数描述，服务端描述一局游戏中最多 8 个玩家的键盘操作为：`int player_keyboards[8]`
2. 服务器每秒钟 20-50 次向所有客户端发送更新消息（包含所有客户端的操作和递增的帧号）：`update=(FrameID,player_keyboards)`
3. 客户端就像播放游戏录像一样不停的播放这些包含每帧所有玩家操作的 update 消息
4. 客户端如果没有 update 数据了，就必须等待直到有新的数据到来
5. 客户端如果一下子收到很多连续的 update，则快进播放
6. 客户端只要按键按下或者放开，就会发送消息给服务器（而不是到每帧开始才采集键盘），消息只包含一个整数。服务器收到以后，改写 `player_keyboards`

随机数需要服务器提前将种子发给各个客户端，各个客户端算逻辑时用该种子生成随机数。

#### 指令缓存

针对高级别的抽象指令（非前后可以覆盖的键盘操作），比如即时战略游戏中的各种高级操作指令。在乐观帧锁定中，客户端任何操作都是可靠消息发送到服务器，服务器缓存在对应玩家的指令队列里面，然后定时向所有人广播所有队列里面的历史操作，广播完成后清空队列，等待新的指令上传。客户端收到后按顺序执行这些指令，为了保证公平性，客户端可以先轮询执行每个用户的第一条指令，执行完以后弹出队列，再进入下一轮，直到没有任何指令。这样在即时战略游戏中，选择 250ms 一个同步帧，每秒四次，已经足够了。如果做的好还可以像 AOE 一样根据网速调整，比如网速快的时候进化为每秒 10 帧，网速慢的时候退化为每秒 4 帧之类的。

#### PS

可以把整段战斗过程的操作和随机数种子记录下来，不但可以当录像播放，还可以交给另外一台服务器延迟验算，还可以交给其它空闲的客户端验算，将验算结果的 hash 值进行比较，如果相同则认可，如果不同则记录或者处理。服务器如果根据游戏当前进程加入一些临时事件（比如天上掉下一个宝箱），可以在广播的时候附带。
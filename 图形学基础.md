# 图形学知识汇总

## 坐标系

有五个坐标系，分别是：

1. 物体坐标系
2. 世界坐标系
3. 观察者坐标系
4. 裁剪空间
5. 屏幕空间

![img](https://img-blog.csdn.net/20170919132521780?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 图形学渲染管线

![img](https://img-blog.csdn.net/20170919142304500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

<img src="https://pic2.zhimg.com/80/v2-e31cc27bd8701332134e6e1a3d138b95_720w.jpg" alt="img" style="zoom: 80%;" />

### 顶点数据

顶点数据用来为后面的顶点着色器等阶段提供处理的数据，是**渲染管线数据的主要来源**。送入到渲染管线的数据包括顶点坐标、纹理坐标、顶点法线和顶点颜色等顶点属性。为了让 OpenGL 明白顶点数据构成的是什么图元，我们需要在绘制指令中传递相对应的图元信息。常见的图元包括：点（GL_POINTS）、线（GL_LINES）、线条（GL_LINE_STRIP）、三角面（GL_TRIANGLES）。

### 顶点着色器

顶点着色器主要功能是**进行坐标变换**。将输入的局部坐标变换到世界坐标（model）、观察坐标（view）和裁剪坐标（projection）。虽然我们也会在顶点着色器进行光照计算（称作高洛德着色），然后经过光栅化插值得到各个片段的颜色，但由于这种方法得到的光照比较不自然，所以一般在片段着色器进行光照计算。

### 曲面细分

曲面细分是**利用镶嵌化处理技术对三角面进行细分，以此来增加物体表面的三角面的数量**，是渲染管线一个可选的阶段。它由外壳着色器（Hull Shader）、镶嵌器（Tessellator）和域着色器（Domain Shader）构成，其中外壳着色器和域着色器是可编程的，而镶嵌器是有硬件管理的。我们可以借助曲面细分的技术实现细节层次（Level-of-Detail）的机制，使得离摄像机越近的物体具有更加丰富的细节，而远离摄像机的物体具有较少的细节。

<img src="https://pic4.zhimg.com/80/v2-ef69550f298430517c9a34bd012cd30b_720w.jpg" alt="img" style="zoom:67%;" />

### 几何着色器

几何着色器也是渲染管线一个可选的阶段。我们知道，顶点着色器的输入是单个顶点（以及属性）， 输出的是经过变换后的顶点。与顶点着色器不同，几何着色器的输入是完整的图元（比如点），**输出可以是一个或多个其他的图元**（比如，三角面），或者不输出任何的图元。几何着色器的拿手好戏就是将输入的点或线扩展成多边形。下图展示了几何着色器如何将点扩展成多边形。

<img src="https://pic3.zhimg.com/80/v2-949db46ce4224077a21510dbbd12400a_720w.jpg" alt="img" style="zoom:67%;" />

### 图元组装

图元组装**将输入的顶点组装成指定的图元**。图元组装阶段会进行裁剪和背面剔除相关的优化，以减少进入光栅化的图元的数量，加速渲染过程。在光栅化之前，还会进行屏幕映射的操作：透视除法和视口变换。

关于透视除法和视口变换到底属于流水线的那个阶段并没有一个权威的说法，某些资料将这两个操作归入到图元组装阶段，某些资料将它归入到光栅化过程，但对我们理解整个渲染管线并没有太大的影响，我们只需要知道在光栅化前需要进行屏幕映射就可以了，所以我们这里将屏幕映射放到了图元组装过程。这两个操作主要是硬件实现，不同厂商会有不同的设计。

### 光栅化

经过图元组装以及屏幕映射阶段后，我们将物体坐标变换到了窗口坐标。光栅化是个离散化的过程，**将3D连续的物体转化为离散屏幕像素点**的过程。包括三角形组装和三角形遍历两个阶段。光栅化会确定图元所覆盖的片段，利用顶点属性插值得到片段的属性信息，然后送到片段着色器进行颜色计算，我们这里需要注意到片段是像素的候选者，只有通过后续的测试，片段才会成为最终显示的像素点。

<img src="https://pic3.zhimg.com/80/v2-0534484ba99fc3b5d87e0cda8078dc02_720w.jpg" alt="img" style="zoom:67%;" />

### 片段着色器

片段着色器在 DirectX 中也成为像素着色器（Pixel Shader）。片段着色器用来**决定屏幕上像素的最终颜色**。在这个阶段会进行光照计算以及阴影处理，是渲染管线高级效果产生的地方。

### 测试混合阶段

管线的最后一个阶段是测试混合阶段。**测试包括裁切测试、Alpha 测试、模板测试和深度测试。没有经过测试的片段会被丢弃，不需要进行混合阶段；经过测试的片段会进入混合阶段**。Alpha 混合可以根据片段的 alpha 值进行混合，用来产生半透明的效果。Alpha 表示的是物体的不透明度，因此 alpha=1 表示完全不透明，alpha=0 表示完全透明。测试混合阶段虽然不是可编程阶段，但是我们可以通过 OpenGL 或 DirectX 提供的接口进行配置，定制混合和测试的方式。

## OpenGL 的缓冲

### 帧缓冲 Frame Buffer

用于创建临时的渲染上下文，帧缓冲是一些二维数组和 OpenGL 所使用存储区的集合：颜色缓存、深度缓存、模板缓存和累计缓存。默认情况下，OpenGL 将帧缓冲区作为渲染最终目的地。此帧缓冲区完全由 Windows 系统生成和管理。这个默认的帧缓存被称作 Windows 系统生成（window-system-provided）的帧缓冲区。

- 颜色缓冲（Color Buffer）包含每个像素的颜色信息。颜色信息可以是颜色索引值（在颜色索引方式下），也可以是颜色的红、绿、蓝三个分量（在 RGBA 方式下），还可以存放表示物体透明度的 Alpha 值。
- 深度缓冲（Depth Buffer）包含每个像素的深度值。深度值与 z 坐标有关，描述物体上某点距离观察点的远近，也可以称为 Z 缓存。
- 模板缓冲（Stencil Buffer）包含物体的模板值。模板值具有屏蔽作用，用于控制绘制的区域，使屏幕上某些区域可画，某些区域不可画。
- 累积缓存（Accumulation Buffer）包含颜色信息。其可以合成一系列的绘制结果，实现某些特殊效果。

### 顶点缓冲 Vertex Buffer

用于缓存顶点数据

### 元素缓冲 Element Buffer

用于缓存顶点序号数据

## Alpha 混合

通用公式：
$$
Color=Src*Srcfactor+Dst*Dstfactor
$$
其中 Color 是混合结果，Src 是源颜色向量也就是纹理本来的颜色，Dst 是目标颜色向量也就是储存在颜色缓冲中当前位置的颜色向量，Srcfactor 和 Dstfactor 分别是源因子和目标因子。先进入颜色缓冲区的是目标颜色，比如在红色方块上绘制绿色方块，则红色是 Dst，绿色是 Src。不同的 factor 导致了不同的混合方式：

![img](https://img-blog.csdn.net/20170919160825636?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

注意，颜色常数向量可以用 `glBlendColor` 函数分开来设置。在使用 alpha 混合前要开启 `glEnable(GL_BLEND)` 。最常用的混合方式是 `glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)` 。

## 颜色向量的计算

颜色向量（归一化的）有两种计算：

1. 数乘，$n*Color$，n 越大，结果越亮。
2. 点乘，$ColorA*ColorB$，是 A 与 B 的混合，越大越亮。

## GLSL 着色器程序的创建

![img](https://img-blog.csdn.net/20170919162716729?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## GLSL 数据传递的方式

### uniform 变量

uniform 变量是外部 application 程序传递给 shader 的变量。因此它是 application 通过函数 `glUniform**()` 赋值的。在 shader 内部，uniform 变量就像是 C 语言里面的常量，它不能被 shader 程序修改。

### attribute 变量

attribute 变量是只能在 vertex shader 中使用的变量。一般用 attribute 变量来表示一些顶点的数据，如顶点坐标、法线、纹理坐标和顶点颜色等。在 application 中，一般用函数 `glBindAttribLocation()` 来绑定每个 attribute 变量的位置，然后用函数 `glVertexAttribPointer()` 为每个 attribute 变量赋值。

### varying（in / out）变量

varying 变量是 vertex 和 fragment shader 之间做数据传递用的。一般 vertex shader 修改 varying 变量的值，然后 fragment shader 使用该 varying 变量的值。因此 varying 变量在 vertex 和 fragment shader 二者之间的声明必须是一致的。application 不能使用此变量。

## 冯氏光照模型

### 环境光

控制因素是环境光强度（ambient strength），和 lightColor 数乘得到 ambient 环境光。然后在用 ambient 和物体颜色 objectColor 点乘。其中环境光强度由程序员指定。
$$
ambient=ambientStrength*lightColor
$$

### 漫反射

控制因素是 diff 散射因子，也是和 lightColor 数乘得到 diffuse 漫反射光，然后用 diffuse 和 objectColor 点乘。diff 散射因子由法线与光线的夹角（点积）得到，漫反射光使物体上与光线排布越近的片段越能从光源处获得更多的亮度。
$$
\begin{align}
diff &= max(dot(norm,lightDir),0) \\
diffuse &= diff*lightColor
\end{align}
$$
<img src="https://img-blog.csdn.net/20170919165425282?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 67%;" />

### 镜面反射

控制因素是 spec 反射强度。和环境光照一样，镜面光照同样依据光的方向向量和物体的法向量，但是这次它会依据观察方向。镜面光照根据光的反射特性。
$$
\begin{align}
spec &= pow(max(dot(viewDir,reflectDir),0),shininess) \\
specular &= spec*lightColor
\end{align}
$$
<img src="https://img-blog.csdn.net/20170919170504112?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl9jaGFp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:67%;" />

## 旋转的三种方法

### 旋转矩阵

优点：

- 旋转轴可以是任意向量。

缺点：

- 旋转其实只需要知道一个向量和一个角度，一共 4 个值的信息，但矩阵却使用了 16 个元素。
- 乘法操作时会增加计算量，造成空间和时间上的一些浪费。

### 欧拉角

优点：

- 容易理解，形象直观。
- 表示更方便，只需要 3 个值（分别对应 x，y，z 轴的旋转角度）。

缺点：

- 要按照一个固定的坐标轴的顺序旋转，不同的顺序会造成不同的结果。
- 会造成万向节锁的现象。如果在旋转中不幸让某些坐标轴重合了就会发生万向节锁，此时会丢失一个方向上的旋转能力，这种情况下无论怎么旋转都不可能得到某些想要的旋转效果，除非我们打破原先的旋转顺序或者同时旋转 3 个坐标轴。
- 由于万向节锁的存在，欧拉旋转无法实现球面平滑插值。

### 四元数

优点：

- 可以避免万向节锁。
- 只需要一个四维的四元数就可以执行绕任意过原点的向量的旋转，在某些实现下比旋转矩阵效率更高。
- 可以提供平滑插值。

缺点：

- 比欧拉旋转稍微复杂了一点，因为多了一个维度。
- 理解困难。

## 多级渐近纹理 mipmap

为了**加快渲染速度和减少图像锯齿**，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为 mipmap 。

多级渐近纹理由一组分辨率逐渐降低的纹理序列组成，每一级纹理宽度和高度都是上一级纹理宽度和高度的一半。宽和高不一定相等，也就是说，这些纹理不一定都是正方形。

## 片段和像素的区别

1. 片段是渲染一个像素需要的全部信息，所有片段经过测试与混合后渲染成像素。
2. 片段是三维顶点光栅化后的数据集合，还没有经过深度测试；而像素是片段经过深度测试、模板测试、alpha 混合之后的结果。
3. 片段的个数远远多于像素，因为有的片段会在测试和混合阶段被丢弃，无法渲染成像素。

## 多边形光栅化算法

### 奇偶测试

假定 p 是多边形内部的某个点，从 p 点发出的射线一定与多边形的奇数条边相交，从多边形外部某点发出并进入多边形的任意射线与多边形的偶数条边相交。因此，如果从多边形外部发出一条直线，该直线在到达某个待判定点之前与多边形的奇数条边相交，那么这个待判定点位于多边形的内部。我们通常使用扫描线代替射线，并根据扫描线与多边形交点的数量来确定多边形的内部区域和外部区域。

### 环绕测试法

我们把多边形的边视为有向边，即从任意一个顶点出发，按某个特定的方向环绕多边形直到回到出发点。下面，考虑一个任意的点，该点的环绕次数定义为多边形的边环绕该点的次数。我们规定顺时针环绕为正，逆时针环绕为负（或者相反）。如果改变填充规则，即规定环绕次数为非 0 的点位于多边形内部区域，那么对于特殊的星形多边形内部就可以正确填充了。

## 多边形填充算法

### 漫水填充算法

对多边形的边进行光栅化处理后，把边的颜色置为前景色，如果能够在多边形的内部区域找到一个初始点，即种子点，那么就可以递归地进行如下的测试和处理：如果它的相邻像素不在多边形的边上，那么就用前景色对它着色。伪代码如下：

```c++
flood_fill(int x, int y)
{
    if (read_pixel(x, y) == WHITE)
    {
        write_pixel(x, y, BLACK);
        flood_fill(x - 1, y);
        flood_fill(x + 1, y);
        flood_fill(x, y - 1);
        flood_fill(x, y + 1);
    }
}
```

### 处理奇点

如果能确保多边形所有顶点的 y 坐标值都不是整数，那么就不会出现奇点。如果我们发现某个奇点的 y 坐标值是整数，只需要稍微扰动它的位置（上移或下移一个像素点）即可消除该奇点。还有另一种方法，也是 OpenGL 采用的方法，就是利用一个两倍于实际帧缓存分辨率的虚拟帧缓存，在帧缓存中，像素只位于 y 为偶数的位置，而所有顶点只位于 y 为奇数的位置，也就是把像素的中心放在两个整数的中间值所在的位置。

## 隐藏面消除算法

### 深度缓存算法 Z-Buffer

假定我们有一个称为 Z-Buffer 的缓存，它与帧缓存具有相同大小的空间分辨率，其深度分辨率就是在存储距离（深度）时，我们希望使用的二进制位数。算法执行时，深度缓存中存储的每个元素都初始化为离投影中心的最大深度值，颜色缓存初始化为背景颜色。**在光栅化和片元处理的任何时刻，Z-Buffer 总是在相应位置存储到目前为止通过该位置的射线与多边形交点的最近距离值**。

对于某个多边形上的每个片元，它对应于通过某个像素位置的射线与该多边形的交点，我们都要计算片元到投影中心的距离（即片元的深度），然后把片元的深度值与 Z-Buffer 相应位置的深度值比较。如果当前片元的深度值更大，那么在它之前已处理的那个多边形上对应的片元离视点更近，所以当前处理的这个片元不可见，直接丢弃。如果当前片元的深度值更小，那么就找到了一个离视点更近的片元，此时我们使用该片元的深度值更新 Z-Buffer 相应位置的深度值，同时把颜色缓存中相应位置的颜色值更新为该片元的颜色。

Z-Buffer 算法可以采用计算开销非常小的增量计算方法。假定基于扫描线光栅化方法正在逐条扫描线地光栅化一个多边形，那么多边形所在的平面方程可以表示为
$$
ax+by+cz+d=0
$$
假定$(x_1,y_1,z_1)$和$(x_2,y_2,z_2)$是多边形平面上的两个点，如果
$$
\Delta x=x_2-x_1 \\
\Delta y=y_2-y_1 \\
\Delta z=z_2-z_1
$$
那么可以用差分的形式来写该平面方程
$$
a\Delta x+b\Delta y+c\Delta z=0
$$
该方程位于屏幕窗口坐标系中，因此每条扫描线都对应于一条 y 为常量的直线，并且 $\Delta y=0$ 。在某条扫描线上按单位步长增加 x 的值，所以 $\Delta x$ 是常量，因此 $\Delta z$ 也是一个常量，所以对每个多边形只需要计算一次。尽管图像空间消隐算法在最坏情况下的性能与图元的数量成正比，但是 Z-Buffer 算法的性能与光栅化过程生成的片元数量成正比，而这取决于光栅化后的多边形的面积。

**使用 Z-Buffer 算法可以同时完成最终正投影变换的计算、隐藏面消除和明暗处理三个任务**。对同一个多边形，从屏幕坐标系逆向投影到规范化的设备坐标系中的一条投影线对应于一条 y 为常量的直线。按照增量计算的方式确定位于规范化设备坐标系中的这条直线上相应点的深度值，从而判断屏幕坐标系中的对应像素是否对应于多边形上的可见点。如果通过光照计算已经得到了原多边形每个顶点的明暗值，那么就可以利用插值来计算可见像素的正确颜色值。

### 画家算法（深度排序）

从后向前绘制多边形，因为深度排序算法需要进行初始排序，所以它的时间复杂度至少是 $O(k\log k)$ ，其中 k 表示对象的数量。

如果某个多边形的最小深度值大于它后面某个多边形的最大深度值，那么我们可以从后向前绘制这些多边形，且可以得到正确的绘制效果。如果两个多边形的 z 值范围有重叠，那么我们可以检测它们的 x 取值范围或 y 取值范围是否有重叠，如果不重叠，说明它们互不遮挡，可以按任意顺序绘制。即使这两个测试失败了，但是其中一个多边形的所有顶点都位于另一个多边形所在平面的同一侧，那么也可以从后向前绘制。

难以处理的情况是，如果有三个或更多的多边形循环重叠，那么最好的办法就是至少把其中一个多边形分割成两个多边形，从而得到一个新的多边形集，然后再试图找到一个正确的绘制顺序。